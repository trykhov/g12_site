{"ast":null,"code":"/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/createClass\");\n\nvar crypto = require('crypto');\n\nvar os = require('os');\n\nvar fs = require('fs');\n\nvar punycode = require('punycode');\n\nvar PassThrough = require('stream').PassThrough;\n\nvar shared = require('../shared');\n\nvar mimeFuncs = require('../mime-funcs');\n\nvar qp = require('../qp');\n\nvar base64 = require('../base64');\n\nvar addressparser = require('../addressparser');\n\nvar fetch = require('../fetch');\n\nvar LastNewline = require('./last-newline');\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\n\n\nvar MimeNode =\n/*#__PURE__*/\nfunction () {\n  function MimeNode(contentType, options) {\n    _classCallCheck(this, MimeNode);\n\n    this.nodeCounter = 0;\n    options = options || {};\n    /**\n     * shared part of the unique multipart boundary\n     */\n\n    this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n    this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n    this.disableFileAccess = !!options.disableFileAccess;\n    this.disableUrlAccess = !!options.disableUrlAccess;\n    this.normalizeHeaderKey = options.normalizeHeaderKey;\n    /**\n     * If date headers is missing and current node is the root, this value is used instead\n     */\n\n    this.date = new Date();\n    /**\n     * Root node for current mime tree\n     */\n\n    this.rootNode = options.rootNode || this;\n    /**\n     * If true include Bcc in generated headers (if available)\n     */\n\n    this.keepBcc = !!options.keepBcc;\n    /**\n     * If filename is specified but contentType is not (probably an attachment)\n     * detect the content type from filename extension\n     */\n\n    if (options.filename) {\n      /**\n       * Filename for this node. Useful with attachments\n       */\n      this.filename = options.filename;\n\n      if (!contentType) {\n        contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n      }\n    }\n    /**\n     * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n     */\n\n\n    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n    /**\n     * Immediate parent for this node (or undefined if not set)\n     */\n\n    this.parentNode = options.parentNode;\n    /**\n     * Hostname for default message-id values\n     */\n\n    this.hostname = options.hostname;\n    /**\n     * An array for possible child nodes\n     */\n\n    this.childNodes = [];\n    /**\n     * Used for generating unique boundaries (prepended to the shared base)\n     */\n\n    this._nodeId = ++this.rootNode.nodeCounter;\n    /**\n     * A list of header values for this node in the form of [{key:'', value:''}]\n     */\n\n    this._headers = [];\n    /**\n     * True if the content only uses ASCII printable characters\n     * @type {Boolean}\n     */\n\n    this._isPlainText = false;\n    /**\n     * True if the content is plain text but has longer lines than allowed\n     * @type {Boolean}\n     */\n\n    this._hasLongLines = false;\n    /**\n     * If set, use instead this value for envelopes instead of generating one\n     * @type {Boolean}\n     */\n\n    this._envelope = false;\n    /**\n     * If set then use this value as the stream content instead of building it\n     * @type {String|Buffer|Stream}\n     */\n\n    this._raw = false;\n    /**\n     * Additional transform streams that the message will be piped before\n     * exposing by createReadStream\n     * @type {Array}\n     */\n\n    this._transforms = [];\n    /**\n     * Additional process functions that the message will be piped through before\n     * exposing by createReadStream. These functions are run after transforms\n     * @type {Array}\n     */\n\n    this._processFuncs = [];\n    /**\n     * If content type is set (or derived from the filename) add it to headers\n     */\n\n    if (contentType) {\n      this.setHeader('Content-Type', contentType);\n    }\n  } /////// PUBLIC METHODS\n\n  /**\n   * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n   *\n   * @param {String} [contentType] Optional content type\n   * @param {Object} [options] Optional options object\n   * @return {Object} Created node object\n   */\n\n\n  _createClass(MimeNode, [{\n    key: \"createChild\",\n    value: function createChild(contentType, options) {\n      if (!options && typeof contentType === 'object') {\n        options = contentType;\n        contentType = undefined;\n      }\n\n      var node = new MimeNode(contentType, options);\n      this.appendChild(node);\n      return node;\n    }\n    /**\n     * Appends an existing node to the mime tree. Removes the node from an existing\n     * tree if needed\n     *\n     * @param {Object} childNode node to be appended\n     * @return {Object} Appended node object\n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(childNode) {\n      if (childNode.rootNode !== this.rootNode) {\n        childNode.rootNode = this.rootNode;\n        childNode._nodeId = ++this.rootNode.nodeCounter;\n      }\n\n      childNode.parentNode = this;\n      this.childNodes.push(childNode);\n      return childNode;\n    }\n    /**\n     * Replaces current node with another node\n     *\n     * @param {Object} node Replacement node\n     * @return {Object} Replacement node\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(node) {\n      var _this = this;\n\n      if (node === this) {\n        return this;\n      }\n\n      this.parentNode.childNodes.forEach(function (childNode, i) {\n        if (childNode === _this) {\n          node.rootNode = _this.rootNode;\n          node.parentNode = _this.parentNode;\n          node._nodeId = _this._nodeId;\n          _this.rootNode = _this;\n          _this.parentNode = undefined;\n          node.parentNode.childNodes[i] = node;\n        }\n      });\n      return node;\n    }\n    /**\n     * Removes current node from the mime tree\n     *\n     * @return {Object} removed node\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (!this.parentNode) {\n        return this;\n      }\n\n      for (var i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n        if (this.parentNode.childNodes[i] === this) {\n          this.parentNode.childNodes.splice(i, 1);\n          this.parentNode = undefined;\n          this.rootNode = this;\n          return this;\n        }\n      }\n    }\n    /**\n     * Sets a header value. If the value for selected key exists, it is overwritten.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(key, value) {\n      var _this2 = this;\n\n      var added = false,\n          headerValue; // Allow setting multiple headers at once\n\n      if (!value && key && typeof key === 'object') {\n        // allow {key:'content-type', value: 'text/plain'}\n        if (key.key && 'value' in key) {\n          this.setHeader(key.key, key.value);\n        } else if (Array.isArray(key)) {\n          // allow [{key:'content-type', value: 'text/plain'}]\n          key.forEach(function (i) {\n            _this2.setHeader(i.key, i.value);\n          });\n        } else {\n          // allow {'content-type': 'text/plain'}\n          Object.keys(key).forEach(function (i) {\n            _this2.setHeader(i, key[i]);\n          });\n        }\n\n        return this;\n      }\n\n      key = this._normalizeHeaderKey(key);\n      headerValue = {\n        key: key,\n        value: value\n      }; // Check if the value exists and overwrite\n\n      for (var i = 0, len = this._headers.length; i < len; i++) {\n        if (this._headers[i].key === key) {\n          if (!added) {\n            // replace the first match\n            this._headers[i] = headerValue;\n            added = true;\n          } else {\n            // remove following matches\n            this._headers.splice(i, 1);\n\n            i--;\n            len--;\n          }\n        }\n      } // match not found, append the value\n\n\n      if (!added) {\n        this._headers.push(headerValue);\n      }\n\n      return this;\n    }\n    /**\n     * Adds a header value. If the value for selected key exists, the value is appended\n     * as a new field and old one is not touched.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n\n  }, {\n    key: \"addHeader\",\n    value: function addHeader(key, value) {\n      var _this3 = this;\n\n      // Allow setting multiple headers at once\n      if (!value && key && typeof key === 'object') {\n        // allow {key:'content-type', value: 'text/plain'}\n        if (key.key && key.value) {\n          this.addHeader(key.key, key.value);\n        } else if (Array.isArray(key)) {\n          // allow [{key:'content-type', value: 'text/plain'}]\n          key.forEach(function (i) {\n            _this3.addHeader(i.key, i.value);\n          });\n        } else {\n          // allow {'content-type': 'text/plain'}\n          Object.keys(key).forEach(function (i) {\n            _this3.addHeader(i, key[i]);\n          });\n        }\n\n        return this;\n      } else if (Array.isArray(value)) {\n        value.forEach(function (val) {\n          _this3.addHeader(key, val);\n        });\n        return this;\n      }\n\n      this._headers.push({\n        key: this._normalizeHeaderKey(key),\n        value: value\n      });\n\n      return this;\n    }\n    /**\n     * Retrieves the first mathcing value of a selected key\n     *\n     * @param {String} key Key to search for\n     * @retun {String} Value for the key\n     */\n\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(key) {\n      key = this._normalizeHeaderKey(key);\n\n      for (var i = 0, len = this._headers.length; i < len; i++) {\n        if (this._headers[i].key === key) {\n          return this._headers[i].value;\n        }\n      }\n    }\n    /**\n     * Sets body content for current node. If the value is a string, charset is added automatically\n     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n     * the charset yourself\n     *\n     * @param (String|Buffer) content Body content\n     * @return {Object} current node\n     */\n\n  }, {\n    key: \"setContent\",\n    value: function setContent(content) {\n      var _this4 = this;\n\n      this.content = content;\n\n      if (typeof this.content.pipe === 'function') {\n        // pre-stream handler. might be triggered if a stream is set as content\n        // and 'error' fires before anything is done with this stream\n        this._contentErrorHandler = function (err) {\n          _this4.content.removeListener('error', _this4._contentErrorHandler);\n\n          _this4.content = err;\n        };\n\n        this.content.once('error', this._contentErrorHandler);\n      } else if (typeof this.content === 'string') {\n        this._isPlainText = mimeFuncs.isPlainText(this.content);\n\n        if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n          // If there are lines longer than 76 symbols/bytes do not use 7bit\n          this._hasLongLines = true;\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build(callback) {\n      var promise;\n\n      if (!callback) {\n        promise = new Promise(function (resolve, reject) {\n          callback = shared.callbackPromise(resolve, reject);\n        });\n      }\n\n      var stream = this.createReadStream();\n      var buf = [];\n      var buflen = 0;\n      var returned = false;\n      stream.on('readable', function () {\n        var chunk;\n\n        while ((chunk = stream.read()) !== null) {\n          buf.push(chunk);\n          buflen += chunk.length;\n        }\n      });\n      stream.once('error', function (err) {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        return callback(err);\n      });\n      stream.once('end', function (chunk) {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n\n        if (chunk && chunk.length) {\n          buf.push(chunk);\n          buflen += chunk.length;\n        }\n\n        return callback(null, Buffer.concat(buf, buflen));\n      });\n      return promise;\n    }\n  }, {\n    key: \"getTransferEncoding\",\n    value: function getTransferEncoding() {\n      var transferEncoding = false;\n      var contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n      if (this.content) {\n        transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n\n        if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n          if (/^text\\//i.test(contentType)) {\n            // If there are no special symbols, no need to modify the text\n            if (this._isPlainText && !this._hasLongLines) {\n              transferEncoding = '7bit';\n            } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n              // detect preferred encoding for string value\n              transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n            } else {\n              // we can not check content for a stream, so either use preferred encoding or fallback to QP\n              transferEncoding = this.transferEncoding === 'B' ? 'base64' : 'quoted-printable';\n            }\n          } else if (!/^(multipart|message)\\//i.test(contentType)) {\n            transferEncoding = transferEncoding || 'base64';\n          }\n        }\n      }\n\n      return transferEncoding;\n    }\n    /**\n     * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n     *\n     * @returns {String} Headers\n     */\n\n  }, {\n    key: \"buildHeaders\",\n    value: function buildHeaders() {\n      var _this5 = this;\n\n      var transferEncoding = this.getTransferEncoding();\n      var headers = [];\n\n      if (transferEncoding) {\n        this.setHeader('Content-Transfer-Encoding', transferEncoding);\n      }\n\n      if (this.filename && !this.getHeader('Content-Disposition')) {\n        this.setHeader('Content-Disposition', 'attachment');\n      } // Ensure mandatory header fields\n\n\n      if (this.rootNode === this) {\n        if (!this.getHeader('Date')) {\n          this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n        } // ensure that Message-Id is present\n\n\n        this.messageId();\n\n        if (!this.getHeader('MIME-Version')) {\n          this.setHeader('MIME-Version', '1.0');\n        }\n      }\n\n      this._headers.forEach(function (header) {\n        var key = header.key;\n        var value = header.value;\n        var structured;\n        var param;\n        var options = {};\n        var formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n        if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n          Object.keys(value).forEach(function (key) {\n            if (key !== 'value') {\n              options[key] = value[key];\n            }\n          });\n          value = (value.value || '').toString();\n\n          if (!value.trim()) {\n            return;\n          }\n        }\n\n        if (options.prepared) {\n          // header value is\n          if (options.foldLines) {\n            headers.push(mimeFuncs.foldLines(key + ': ' + value));\n          } else {\n            headers.push(key + ': ' + value);\n          }\n\n          return;\n        }\n\n        switch (header.key) {\n          case 'Content-Disposition':\n            structured = mimeFuncs.parseHeaderValue(value);\n\n            if (_this5.filename) {\n              structured.params.filename = _this5.filename;\n            }\n\n            value = mimeFuncs.buildHeaderValue(structured);\n            break;\n\n          case 'Content-Type':\n            structured = mimeFuncs.parseHeaderValue(value);\n\n            _this5._handleContentType(structured);\n\n            if (structured.value.match(/^text\\/plain\\b/) && typeof _this5.content === 'string' && /[\\u0080-\\uFFFF]/.test(_this5.content)) {\n              structured.params.charset = 'utf-8';\n            }\n\n            value = mimeFuncs.buildHeaderValue(structured);\n\n            if (_this5.filename) {\n              // add support for non-compliant clients like QQ webmail\n              // we can't build the value with buildHeaderValue as the value is non standard and\n              // would be converted to parameter continuation encoding that we do not want\n              param = _this5._encodeWords(_this5.filename);\n\n              if (param !== _this5.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n                // include value in quotes if needed\n                param = '\"' + param + '\"';\n              }\n\n              value += '; name=' + param;\n            }\n\n            break;\n\n          case 'Bcc':\n            if (!_this5.keepBcc) {\n              // skip BCC values\n              return;\n            }\n\n            break;\n        }\n\n        value = _this5._encodeHeaderValue(key, value); // skip empty lines\n\n        if (!(value || '').toString().trim()) {\n          return;\n        }\n\n        if (typeof _this5.normalizeHeaderKey === 'function') {\n          var normalized = _this5.normalizeHeaderKey(key, value);\n\n          if (normalized && typeof normalized === 'string' && normalized.length) {\n            key = normalized;\n          }\n        }\n\n        headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n      });\n\n      return headers.join('\\r\\n');\n    }\n    /**\n     * Streams the rfc2822 message from the current node. If this is a root node,\n     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n     *\n     * @return {String} Compiled message\n     */\n\n  }, {\n    key: \"createReadStream\",\n    value: function createReadStream(options) {\n      options = options || {};\n      var stream = new PassThrough(options);\n      var outputStream = stream;\n      var transform;\n      this.stream(stream, options, function (err) {\n        if (err) {\n          outputStream.emit('error', err);\n          return;\n        }\n\n        stream.end();\n      });\n\n      for (var i = 0, len = this._transforms.length; i < len; i++) {\n        transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n        outputStream.once('error', function (err) {\n          transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n      } // ensure terminating newline after possible user transforms\n\n\n      transform = new LastNewline();\n      outputStream.once('error', function (err) {\n        transform.emit('error', err);\n      });\n      outputStream = outputStream.pipe(transform); // dkim and stuff\n\n      for (var _i = 0, _len = this._processFuncs.length; _i < _len; _i++) {\n        transform = this._processFuncs[_i];\n        outputStream = transform(outputStream);\n      }\n\n      return outputStream;\n    }\n    /**\n     * Appends a transform stream object to the transforms list. Final output\n     * is passed through this stream before exposing\n     *\n     * @param {Object} transform Read-Write stream\n     */\n\n  }, {\n    key: \"transform\",\n    value: function transform(_transform) {\n      this._transforms.push(_transform);\n    }\n    /**\n     * Appends a post process function. The functon is run after transforms and\n     * uses the following syntax\n     *\n     *   processFunc(input) -> outputStream\n     *\n     * @param {Object} processFunc Read-Write stream\n     */\n\n  }, {\n    key: \"processFunc\",\n    value: function processFunc(_processFunc) {\n      this._processFuncs.push(_processFunc);\n    }\n  }, {\n    key: \"stream\",\n    value: function stream(outputStream, options, done) {\n      var _this6 = this;\n\n      var transferEncoding = this.getTransferEncoding();\n      var contentStream;\n      var localStream; // protect actual callback against multiple triggering\n\n      var returned = false;\n\n      var callback = function callback(err) {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        done(err);\n      }; // for multipart nodes, push child nodes\n      // for content nodes end the stream\n\n\n      var finalize = function finalize() {\n        var childId = 0;\n\n        var processChildNode = function processChildNode() {\n          if (childId >= _this6.childNodes.length) {\n            outputStream.write('\\r\\n--' + _this6.boundary + '--\\r\\n');\n            return callback();\n          }\n\n          var child = _this6.childNodes[childId++];\n          outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + _this6.boundary + '\\r\\n');\n          child.stream(outputStream, options, function (err) {\n            if (err) {\n              return callback(err);\n            }\n\n            setImmediate(processChildNode);\n          });\n        };\n\n        if (_this6.multipart) {\n          setImmediate(processChildNode);\n        } else {\n          return callback();\n        }\n      }; // pushes node content\n\n\n      var sendContent = function sendContent() {\n        if (_this6.content) {\n          if (Object.prototype.toString.call(_this6.content) === '[object Error]') {\n            // content is already errored\n            return callback(_this6.content);\n          }\n\n          if (typeof _this6.content.pipe === 'function') {\n            _this6.content.removeListener('error', _this6._contentErrorHandler);\n\n            _this6._contentErrorHandler = function (err) {\n              return callback(err);\n            };\n\n            _this6.content.once('error', _this6._contentErrorHandler);\n          }\n\n          var createStream = function createStream() {\n            if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n              contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n              contentStream.pipe(outputStream, {\n                end: false\n              });\n              contentStream.once('end', finalize);\n              contentStream.once('error', function (err) {\n                return callback(err);\n              });\n              localStream = _this6._getStream(_this6.content);\n              localStream.pipe(contentStream);\n            } else {\n              // anything that is not QP or Base54 passes as-is\n              localStream = _this6._getStream(_this6.content);\n              localStream.pipe(outputStream, {\n                end: false\n              });\n              localStream.once('end', finalize);\n            }\n\n            localStream.once('error', function (err) {\n              return callback(err);\n            });\n          };\n\n          if (_this6.content._resolve) {\n            var chunks = [];\n            var chunklen = 0;\n            var _returned = false;\n\n            var sourceStream = _this6._getStream(_this6.content);\n\n            sourceStream.on('error', function (err) {\n              if (_returned) {\n                return;\n              }\n\n              _returned = true;\n              callback(err);\n            });\n            sourceStream.on('readable', function () {\n              var chunk;\n\n              while ((chunk = sourceStream.read()) !== null) {\n                chunks.push(chunk);\n                chunklen += chunk.length;\n              }\n            });\n            sourceStream.on('end', function () {\n              if (_returned) {\n                return;\n              }\n\n              _returned = true;\n              _this6.content._resolve = false;\n              _this6.content._resolvedValue = Buffer.concat(chunks, chunklen);\n              setImmediate(createStream);\n            });\n          } else {\n            setImmediate(createStream);\n          }\n\n          return;\n        } else {\n          return setImmediate(finalize);\n        }\n      };\n\n      if (this._raw) {\n        setImmediate(function () {\n          if (Object.prototype.toString.call(_this6._raw) === '[object Error]') {\n            // content is already errored\n            return callback(_this6._raw);\n          } // remove default error handler (if set)\n\n\n          if (typeof _this6._raw.pipe === 'function') {\n            _this6._raw.removeListener('error', _this6._contentErrorHandler);\n          }\n\n          var raw = _this6._getStream(_this6._raw);\n\n          raw.pipe(outputStream, {\n            end: false\n          });\n          raw.on('error', function (err) {\n            return outputStream.emit('error', err);\n          });\n          raw.on('end', finalize);\n        });\n      } else {\n        outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n        setImmediate(sendContent);\n      }\n    }\n    /**\n     * Sets envelope to be used instead of the generated one\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n\n  }, {\n    key: \"setEnvelope\",\n    value: function setEnvelope(envelope) {\n      var _this7 = this;\n\n      var list;\n      this._envelope = {\n        from: false,\n        to: []\n      };\n\n      if (envelope.from) {\n        list = [];\n\n        this._convertAddresses(this._parseAddresses(envelope.from), list);\n\n        list = list.filter(function (address) {\n          return address && address.address;\n        });\n\n        if (list.length && list[0]) {\n          this._envelope.from = list[0].address;\n        }\n      }\n\n      ['to', 'cc', 'bcc'].forEach(function (key) {\n        if (envelope[key]) {\n          _this7._convertAddresses(_this7._parseAddresses(envelope[key]), _this7._envelope.to);\n        }\n      });\n      this._envelope.to = this._envelope.to.map(function (to) {\n        return to.address;\n      }).filter(function (address) {\n        return address;\n      });\n      var standardFields = ['to', 'cc', 'bcc', 'from'];\n      Object.keys(envelope).forEach(function (key) {\n        if (!standardFields.includes(key)) {\n          _this7._envelope[key] = envelope[key];\n        }\n      });\n      return this;\n    }\n    /**\n     * Generates and returns an object with parsed address fields\n     *\n     * @return {Object} Address object\n     */\n\n  }, {\n    key: \"getAddresses\",\n    value: function getAddresses() {\n      var _this8 = this;\n\n      var addresses = {};\n\n      this._headers.forEach(function (header) {\n        var key = header.key.toLowerCase();\n\n        if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n          if (!Array.isArray(addresses[key])) {\n            addresses[key] = [];\n          }\n\n          _this8._convertAddresses(_this8._parseAddresses(header.value), addresses[key]);\n        }\n      });\n\n      return addresses;\n    }\n    /**\n     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n\n  }, {\n    key: \"getEnvelope\",\n    value: function getEnvelope() {\n      var _this9 = this;\n\n      if (this._envelope) {\n        return this._envelope;\n      }\n\n      var envelope = {\n        from: false,\n        to: []\n      };\n\n      this._headers.forEach(function (header) {\n        var list = [];\n\n        if (header.key === 'From' || !envelope.from && ['Reply-To', 'Sender'].includes(header.key)) {\n          _this9._convertAddresses(_this9._parseAddresses(header.value), list);\n\n          if (list.length && list[0]) {\n            envelope.from = list[0].address;\n          }\n        } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n          _this9._convertAddresses(_this9._parseAddresses(header.value), envelope.to);\n        }\n      });\n\n      envelope.to = envelope.to.map(function (to) {\n        return to.address;\n      });\n      return envelope;\n    }\n    /**\n     * Returns Message-Id value. If it does not exist, then creates one\n     *\n     * @return {String} Message-Id value\n     */\n\n  }, {\n    key: \"messageId\",\n    value: function messageId() {\n      var messageId = this.getHeader('Message-ID'); // You really should define your own Message-Id field!\n\n      if (!messageId) {\n        messageId = this._generateMessageId();\n        this.setHeader('Message-ID', messageId);\n      }\n\n      return messageId;\n    }\n    /**\n     * Sets pregenerated content that will be used as the output of this node\n     *\n     * @param {String|Buffer|Stream} Raw MIME contents\n     */\n\n  }, {\n    key: \"setRaw\",\n    value: function setRaw(raw) {\n      var _this10 = this;\n\n      this._raw = raw;\n\n      if (this._raw && typeof this._raw.pipe === 'function') {\n        // pre-stream handler. might be triggered if a stream is set as content\n        // and 'error' fires before anything is done with this stream\n        this._contentErrorHandler = function (err) {\n          _this10._raw.removeListener('error', _this10._contentErrorHandler);\n\n          _this10._raw = err;\n        };\n\n        this._raw.once('error', this._contentErrorHandler);\n      }\n\n      return this;\n    } /////// PRIVATE METHODS\n\n    /**\n     * Detects and returns handle to a stream related with the content.\n     *\n     * @param {Mixed} content Node content\n     * @returns {Object} Stream object\n     */\n\n  }, {\n    key: \"_getStream\",\n    value: function _getStream(content) {\n      var contentStream;\n\n      if (content._resolvedValue) {\n        // pass string or buffer content as a stream\n        contentStream = new PassThrough();\n        setImmediate(function () {\n          return contentStream.end(content._resolvedValue);\n        });\n        return contentStream;\n      } else if (typeof content.pipe === 'function') {\n        // assume as stream\n        return content;\n      } else if (content && typeof content.path === 'string' && !content.href) {\n        if (this.disableFileAccess) {\n          contentStream = new PassThrough();\n          setImmediate(function () {\n            return contentStream.emit('error', new Error('File access rejected for ' + content.path));\n          });\n          return contentStream;\n        } // read file\n\n\n        return fs.createReadStream(content.path);\n      } else if (content && typeof content.href === 'string') {\n        if (this.disableUrlAccess) {\n          contentStream = new PassThrough();\n          setImmediate(function () {\n            return contentStream.emit('error', new Error('Url access rejected for ' + content.href));\n          });\n          return contentStream;\n        } // fetch URL\n\n\n        return fetch(content.href);\n      } else {\n        // pass string or buffer content as a stream\n        contentStream = new PassThrough();\n        setImmediate(function () {\n          return contentStream.end(content || '');\n        });\n        return contentStream;\n      }\n    }\n    /**\n     * Parses addresses. Takes in a single address or an array or an\n     * array of address arrays (eg. To: [[first group], [second group],...])\n     *\n     * @param {Mixed} addresses Addresses to be parsed\n     * @return {Array} An array of address objects\n     */\n\n  }, {\n    key: \"_parseAddresses\",\n    value: function _parseAddresses(addresses) {\n      var _this11 = this;\n\n      return [].concat.apply([], [].concat(addresses).map(function (address) {\n        // eslint-disable-line prefer-spread\n        if (address && address.address) {\n          address.address = _this11._normalizeAddress(address.address);\n          address.name = address.name || '';\n          return [address];\n        }\n\n        return addressparser(address);\n      }));\n    }\n    /**\n     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n     *\n     * @param {String} key Key to be normalized\n     * @return {String} key in Camel-Case form\n     */\n\n  }, {\n    key: \"_normalizeHeaderKey\",\n    value: function _normalizeHeaderKey(key) {\n      key = (key || '').toString() // no newlines in keys\n      .replace(/\\r?\\n|\\r/g, ' ').trim().toLowerCase() // use uppercase words, except MIME\n      .replace(/^X-SMTPAPI$|^(MIME|DKIM)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, function (c) {\n        return c.toUpperCase();\n      }) // special case\n      .replace(/^Content-Features$/i, 'Content-features');\n      return key;\n    }\n    /**\n     * Checks if the content type is multipart and defines boundary if needed.\n     * Doesn't return anything, modifies object argument instead.\n     *\n     * @param {Object} structured Parsed header value for 'Content-Type' key\n     */\n\n  }, {\n    key: \"_handleContentType\",\n    value: function _handleContentType(structured) {\n      this.contentType = structured.value.trim().toLowerCase();\n      this.multipart = this.contentType.split('/').reduce(function (prev, value) {\n        return prev === 'multipart' ? value : false;\n      });\n\n      if (this.multipart) {\n        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n      } else {\n        this.boundary = false;\n      }\n    }\n    /**\n     * Generates a multipart boundary value\n     *\n     * @return {String} boundary value\n     */\n\n  }, {\n    key: \"_generateBoundary\",\n    value: function _generateBoundary() {\n      return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n    }\n    /**\n     * Encodes a header value for use in the generated rfc2822 email.\n     *\n     * @param {String} key Header key\n     * @param {String} value Header value\n     */\n\n  }, {\n    key: \"_encodeHeaderValue\",\n    value: function _encodeHeaderValue(key, value) {\n      key = this._normalizeHeaderKey(key);\n\n      switch (key) {\n        // Structured headers\n        case 'From':\n        case 'Sender':\n        case 'To':\n        case 'Cc':\n        case 'Bcc':\n        case 'Reply-To':\n          return this._convertAddresses(this._parseAddresses(value));\n        // values enclosed in <>\n\n        case 'Message-ID':\n        case 'In-Reply-To':\n        case 'Content-Id':\n          value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n          if (value.charAt(0) !== '<') {\n            value = '<' + value;\n          }\n\n          if (value.charAt(value.length - 1) !== '>') {\n            value = value + '>';\n          }\n\n          return value;\n        // space separated list of values enclosed in <>\n\n        case 'References':\n          value = [].concat.apply([], [].concat(value || '').map(function (elm) {\n            // eslint-disable-line prefer-spread\n            elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n            return elm.replace(/<[^>]*>/g, function (str) {\n              return str.replace(/\\s/g, '');\n            }).split(/\\s+/);\n          })).map(function (elm) {\n            if (elm.charAt(0) !== '<') {\n              elm = '<' + elm;\n            }\n\n            if (elm.charAt(elm.length - 1) !== '>') {\n              elm = elm + '>';\n            }\n\n            return elm;\n          });\n          return value.join(' ').trim();\n\n        case 'Date':\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            return value.toUTCString().replace(/GMT/, '+0000');\n          }\n\n          value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n          return this._encodeWords(value);\n\n        default:\n          value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' '); // encodeWords only encodes if needed, otherwise the original string is returned\n\n          return this._encodeWords(value);\n      }\n    }\n    /**\n     * Rebuilds address object using punycode and other adjustments\n     *\n     * @param {Array} addresses An array of address objects\n     * @param {Array} [uniqueList] An array to be populated with addresses\n     * @return {String} address string\n     */\n\n  }, {\n    key: \"_convertAddresses\",\n    value: function _convertAddresses(addresses, uniqueList) {\n      var _this12 = this;\n\n      var values = [];\n      uniqueList = uniqueList || [];\n      [].concat(addresses || []).forEach(function (address) {\n        if (address.address) {\n          address.address = _this12._normalizeAddress(address.address);\n\n          if (!address.name) {\n            values.push(address.address);\n          } else if (address.name) {\n            values.push(_this12._encodeAddressName(address.name) + ' <' + address.address + '>');\n          }\n\n          if (address.address) {\n            if (!uniqueList.filter(function (a) {\n              return a.address === address.address;\n            }).length) {\n              uniqueList.push(address);\n            }\n          }\n        } else if (address.group) {\n          values.push(_this12._encodeAddressName(address.name) + ':' + (address.group.length ? _this12._convertAddresses(address.group, uniqueList) : '').trim() + ';');\n        }\n      });\n      return values.join(', ');\n    }\n    /**\n     * Normalizes an email address\n     *\n     * @param {Array} address An array of address objects\n     * @return {String} address string\n     */\n\n  }, {\n    key: \"_normalizeAddress\",\n    value: function _normalizeAddress(address) {\n      address = (address || '').toString().trim();\n      var lastAt = address.lastIndexOf('@');\n\n      if (lastAt < 0) {\n        // Bare username\n        return address;\n      }\n\n      var user = address.substr(0, lastAt);\n      var domain = address.substr(lastAt + 1); // Usernames are not touched and are kept as is even if these include unicode\n      // Domains are punycoded by default\n      // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n      // non-unicode domains are left as is\n\n      return user + '@' + punycode.toASCII(domain.toLowerCase());\n    }\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n\n  }, {\n    key: \"_encodeAddressName\",\n    value: function _encodeAddressName(name) {\n      if (!/^[\\w ']*$/.test(name)) {\n        if (/^[\\x20-\\x7e]*$/.test(name)) {\n          return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n        } else {\n          return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n        }\n      }\n\n      return name;\n    }\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n\n  }, {\n    key: \"_encodeWords\",\n    value: function _encodeWords(value) {\n      // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n      // by default only words that include non-ascii should be converted into encoded words\n      // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n      return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n    }\n    /**\n     * Detects best mime encoding for a text value\n     *\n     * @param {String} value Value to check for\n     * @return {String} either 'Q' or 'B'\n     */\n\n  }, {\n    key: \"_getTextEncoding\",\n    value: function _getTextEncoding(value) {\n      value = (value || '').toString();\n      var encoding = this.textEncoding;\n      var latinLen;\n      var nonLatinLen;\n\n      if (!encoding) {\n        // count latin alphabet symbols and 8-bit range symbols + control symbols\n        // if there are more latin characters, then use quoted-printable\n        // encoding, otherwise use base64\n        nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n\n        latinLen = (value.match(/[a-z]/gi) || []).length; // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n\n        encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n      }\n\n      return encoding;\n    }\n    /**\n     * Generates a message id\n     *\n     * @return {String} Random Message-ID value\n     */\n\n  }, {\n    key: \"_generateMessageId\",\n    value: function _generateMessageId() {\n      return '<' + [2, 2, 2, 6].reduce( // crux to generate UUID-like random strings\n      function (prev, len) {\n        return prev + '-' + crypto.randomBytes(len).toString('hex');\n      }, crypto.randomBytes(4).toString('hex')) + '@' + // try to use the domain of the FROM address or fallback to server hostname\n      (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() + '>';\n    }\n  }]);\n\n  return MimeNode;\n}();\n\nmodule.exports = MimeNode;","map":null,"metadata":{},"sourceType":"script"}