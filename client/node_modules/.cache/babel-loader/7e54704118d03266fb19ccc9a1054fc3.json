{"ast":null,"code":"'use strict';\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\n\nvar _classCallCheck = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _handleAddress(tokens) {\n  var token;\n  var isGroup = false;\n  var state = 'text';\n  var address;\n  var addresses = [];\n  var data = {\n    address: [],\n    comment: [],\n    group: [],\n    text: []\n  };\n  var i;\n  var len; // Filter out <addresses>, (comments) and regular text\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    token = tokens[i];\n\n    if (token.type === 'operator') {\n      switch (token.value) {\n        case '<':\n          state = 'address';\n          break;\n\n        case '(':\n          state = 'comment';\n          break;\n\n        case ':':\n          state = 'group';\n          isGroup = true;\n          break;\n\n        default:\n          state = 'text';\n      }\n    } else if (token.value) {\n      if (state === 'address') {\n        // handle use case where unquoted name includes a \"<\"\n        // Apple Mail truncates everything between an unexpected < and an address\n        // and so will we\n        token.value = token.value.replace(/^[^<]*<\\s*/, '');\n      }\n\n      data[state].push(token.value);\n    }\n  } // If there is no text but a comment, replace the two\n\n\n  if (!data.text.length && data.comment.length) {\n    data.text = data.comment;\n    data.comment = [];\n  }\n\n  if (isGroup) {\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    data.text = data.text.join(' ');\n    addresses.push({\n      name: data.text || address && address.name,\n      group: data.group.length ? addressparser(data.group.join(',')) : []\n    });\n  } else {\n    // If no address was found, try to detect one from regular text\n    if (!data.address.length && data.text.length) {\n      for (i = data.text.length - 1; i >= 0; i--) {\n        if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n          data.address = data.text.splice(i, 1);\n          break;\n        }\n      }\n\n      var _regexHandler = function _regexHandler(address) {\n        if (!data.address.length) {\n          data.address = [address.trim()];\n          return ' ';\n        } else {\n          return address;\n        }\n      }; // still no address\n\n\n      if (!data.address.length) {\n        for (i = data.text.length - 1; i >= 0; i--) {\n          // fixed the regex to parse email address correctly when email address has more than one @\n          data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n\n          if (data.address.length) {\n            break;\n          }\n        }\n      }\n    } // If there's still is no text but a comment exixts, replace the two\n\n\n    if (!data.text.length && data.comment.length) {\n      data.text = data.comment;\n      data.comment = [];\n    } // Keep only the first address occurence, push others to regular text\n\n\n    if (data.address.length > 1) {\n      data.text = data.text.concat(data.address.splice(1));\n    } // Join values with spaces\n\n\n    data.text = data.text.join(' ');\n    data.address = data.address.join(' ');\n\n    if (!data.address && isGroup) {\n      return [];\n    } else {\n      address = {\n        address: data.address || data.text || '',\n        name: data.text || data.address || ''\n      };\n\n      if (address.address === address.name) {\n        if ((address.address || '').match(/@/)) {\n          address.name = '';\n        } else {\n          address.address = '';\n        }\n      }\n\n      addresses.push(address);\n    }\n  }\n\n  return addresses;\n}\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\n\n\nvar Tokenizer =\n/*#__PURE__*/\nfunction () {\n  function Tokenizer(str) {\n    _classCallCheck(this, Tokenizer);\n\n    this.str = (str || '').toString();\n    this.operatorCurrent = '';\n    this.operatorExpecting = '';\n    this.node = null;\n    this.escaped = false;\n    this.list = [];\n    /**\n     * Operator tokens and which tokens are expected to end the sequence\n     */\n\n    this.operators = {\n      '\"': '\"',\n      '(': ')',\n      '<': '>',\n      ',': '',\n      ':': ';',\n      // Semicolons are not a legal delimiter per the RFC2822 grammar other\n      // than for terminating a group, but they are also not valid for any\n      // other use in this context.  Given that some mail clients have\n      // historically allowed the semicolon as a delimiter equivalent to the\n      // comma in their UI, it makes sense to treat them the same as a comma\n      // when used outside of a group.\n      ';': ''\n    };\n  }\n  /**\n   * Tokenizes the original input string\n   *\n   * @return {Array} An array of operator|text tokens\n   */\n\n\n  _createClass(Tokenizer, [{\n    key: \"tokenize\",\n    value: function tokenize() {\n      var chr,\n          list = [];\n\n      for (var i = 0, len = this.str.length; i < len; i++) {\n        chr = this.str.charAt(i);\n        this.checkChar(chr);\n      }\n\n      this.list.forEach(function (node) {\n        node.value = (node.value || '').toString().trim();\n\n        if (node.value) {\n          list.push(node);\n        }\n      });\n      return list;\n    }\n    /**\n     * Checks if a character is an operator or text and acts accordingly\n     *\n     * @param {String} chr Character from the address field\n     */\n\n  }, {\n    key: \"checkChar\",\n    value: function checkChar(chr) {\n      if ((chr in this.operators || chr === '\\\\') && this.escaped) {\n        this.escaped = false;\n      } else if (this.operatorExpecting && chr === this.operatorExpecting) {\n        this.node = {\n          type: 'operator',\n          value: chr\n        };\n        this.list.push(this.node);\n        this.node = null;\n        this.operatorExpecting = '';\n        this.escaped = false;\n        return;\n      } else if (!this.operatorExpecting && chr in this.operators) {\n        this.node = {\n          type: 'operator',\n          value: chr\n        };\n        this.list.push(this.node);\n        this.node = null;\n        this.operatorExpecting = this.operators[chr];\n        this.escaped = false;\n        return;\n      }\n\n      if (!this.escaped && chr === '\\\\') {\n        this.escaped = true;\n        return;\n      }\n\n      if (!this.node) {\n        this.node = {\n          type: 'text',\n          value: ''\n        };\n        this.list.push(this.node);\n      }\n\n      if (this.escaped && chr !== '\\\\') {\n        this.node.value += '\\\\';\n      }\n\n      this.node.value += chr;\n      this.escaped = false;\n    }\n  }]);\n\n  return Tokenizer;\n}();\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\n\n\nfunction addressparser(str) {\n  var tokenizer = new Tokenizer(str);\n  var tokens = tokenizer.tokenize();\n  var addresses = [];\n  var address = [];\n  var parsedAddresses = [];\n  tokens.forEach(function (token) {\n    if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n      if (address.length) {\n        addresses.push(address);\n      }\n\n      address = [];\n    } else {\n      address.push(token);\n    }\n  });\n\n  if (address.length) {\n    addresses.push(address);\n  }\n\n  addresses.forEach(function (address) {\n    address = _handleAddress(address);\n\n    if (address.length) {\n      parsedAddresses = parsedAddresses.concat(address);\n    }\n  });\n  return parsedAddresses;\n} // expose to the world\n\n\nmodule.exports = addressparser;","map":null,"metadata":{},"sourceType":"script"}