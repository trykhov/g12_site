{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/inherits\");\n\nvar SMTPConnection = require('../smtp-connection');\n\nvar assign = require('../shared').assign;\n\nvar XOAuth2 = require('../xoauth2');\n\nvar EventEmitter = require('events');\n/**\n * Creates an element for the pool\n *\n * @constructor\n * @param {Object} options SMTPPool instance\n */\n\n\nvar PoolResource =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(PoolResource, _EventEmitter);\n\n  function PoolResource(pool) {\n    var _this;\n\n    _classCallCheck(this, PoolResource);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PoolResource).call(this));\n    _this.pool = pool;\n    _this.options = pool.options;\n    _this.logger = _this.pool.logger;\n\n    if (_this.options.auth) {\n      switch ((_this.options.auth.type || '').toString().toUpperCase()) {\n        case 'OAUTH2':\n          {\n            var oauth2 = new XOAuth2(_this.options.auth, _this.logger);\n            oauth2.provisionCallback = _this.pool.mailer && _this.pool.mailer.get('oauth2_provision_cb') || oauth2.provisionCallback;\n            _this.auth = {\n              type: 'OAUTH2',\n              user: _this.options.auth.user,\n              oauth2: oauth2,\n              method: 'XOAUTH2'\n            };\n            oauth2.on('token', function (token) {\n              return _this.pool.mailer.emit('token', token);\n            });\n            oauth2.on('error', function (err) {\n              return _this.emit('error', err);\n            });\n            break;\n          }\n\n        default:\n          if (!_this.options.auth.user && !_this.options.auth.pass) {\n            break;\n          }\n\n          _this.auth = {\n            type: (_this.options.auth.type || '').toString().toUpperCase() || 'LOGIN',\n            user: _this.options.auth.user,\n            credentials: {\n              user: _this.options.auth.user || '',\n              pass: _this.options.auth.pass,\n              options: _this.options.auth.options\n            },\n            method: (_this.options.auth.method || '').trim().toUpperCase() || false\n          };\n      }\n    }\n\n    _this._connection = false;\n    _this._connected = false;\n    _this.messages = 0;\n    _this.available = true;\n    return _this;\n  }\n  /**\n   * Initiates a connection to the SMTP server\n   *\n   * @param {Function} callback Callback function to run once the connection is established or failed\n   */\n\n\n  _createClass(PoolResource, [{\n    key: \"connect\",\n    value: function connect(callback) {\n      var _this2 = this;\n\n      this.pool.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n          return callback(err);\n        }\n\n        var returned = false;\n        var options = _this2.options;\n\n        if (socketOptions && socketOptions.connection) {\n          _this2.logger.info({\n            tnx: 'proxy',\n            remoteAddress: socketOptions.connection.remoteAddress,\n            remotePort: socketOptions.connection.remotePort,\n            destHost: options.host || '',\n            destPort: options.port || '',\n            action: 'connected'\n          }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n\n          options = assign(false, options);\n          Object.keys(socketOptions).forEach(function (key) {\n            options[key] = socketOptions[key];\n          });\n        }\n\n        _this2.connection = new SMTPConnection(options);\n\n        _this2.connection.once('error', function (err) {\n          _this2.emit('error', err);\n\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          return callback(err);\n        });\n\n        _this2.connection.once('end', function () {\n          _this2.close();\n\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          var timer = setTimeout(function () {\n            if (returned) {\n              return;\n            } // still have not returned, this means we have an unexpected connection close\n\n\n            var err = new Error('Unexpected socket close');\n\n            if (_this2.connection && _this2.connection._socket && _this2.connection._socket.upgrading) {\n              // starttls connection errors\n              err.code = 'ETLS';\n            }\n\n            callback(err);\n          }, 1000);\n\n          try {\n            timer.unref();\n          } catch (E) {// Ignore. Happens on envs with non-node timer implementation\n          }\n        });\n\n        _this2.connection.connect(function () {\n          if (returned) {\n            return;\n          }\n\n          if (_this2.auth) {\n            _this2.connection.login(_this2.auth, function (err) {\n              if (returned) {\n                return;\n              }\n\n              returned = true;\n\n              if (err) {\n                _this2.connection.close();\n\n                _this2.emit('error', err);\n\n                return callback(err);\n              }\n\n              _this2._connected = true;\n              callback(null, true);\n            });\n          } else {\n            returned = true;\n            _this2._connected = true;\n            return callback(null, true);\n          }\n        });\n      });\n    }\n    /**\n     * Sends an e-mail to be sent using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(mail, callback) {\n      var _this3 = this;\n\n      if (!this._connected) {\n        return this.connect(function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          return _this3.send(mail, callback);\n        });\n      }\n\n      var envelope = mail.message.getEnvelope();\n      var messageId = mail.message.messageId();\n      var recipients = [].concat(envelope.to || []);\n\n      if (recipients.length > 3) {\n        recipients.push('...and ' + recipients.splice(2).length + ' more');\n      }\n\n      this.logger.info({\n        tnx: 'send',\n        messageId: messageId,\n        cid: this.id\n      }, 'Sending message %s using #%s to <%s>', messageId, this.id, recipients.join(', '));\n\n      if (mail.data.dsn) {\n        envelope.dsn = mail.data.dsn;\n      }\n\n      this.connection.send(envelope, mail.message.createReadStream(), function (err, info) {\n        _this3.messages++;\n\n        if (err) {\n          _this3.connection.close();\n\n          _this3.emit('error', err);\n\n          return callback(err);\n        }\n\n        info.envelope = {\n          from: envelope.from,\n          to: envelope.to\n        };\n        info.messageId = messageId;\n        setImmediate(function () {\n          var err;\n\n          if (_this3.messages >= _this3.options.maxMessages) {\n            err = new Error('Resource exhausted');\n            err.code = 'EMAXLIMIT';\n\n            _this3.connection.close();\n\n            _this3.emit('error', err);\n          } else {\n            _this3.pool._checkRateLimit(function () {\n              _this3.available = true;\n\n              _this3.emit('available');\n            });\n          }\n        });\n        callback(null, info);\n      });\n    }\n    /**\n     * Closes the connection\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this._connected = false;\n\n      if (this.auth && this.auth.oauth2) {\n        this.auth.oauth2.removeAllListeners();\n      }\n\n      if (this.connection) {\n        this.connection.close();\n      }\n\n      this.emit('close');\n    }\n  }]);\n\n  return PoolResource;\n}(EventEmitter);\n\nmodule.exports = PoolResource;","map":null,"metadata":{},"sourceType":"script"}