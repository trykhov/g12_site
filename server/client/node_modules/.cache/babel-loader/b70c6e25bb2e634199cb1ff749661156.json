{"ast":null,"code":"/* eslint no-undefined: 0 */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/createClass\");\n\nvar MimeNode = require('../mime-node');\n\nvar mimeFuncs = require('../mime-funcs');\n/**\n * Creates the object for composing a MimeNode instance out from the mail options\n *\n * @constructor\n * @param {Object} mail Mail options\n */\n\n\nvar MailComposer =\n/*#__PURE__*/\nfunction () {\n  function MailComposer(mail) {\n    _classCallCheck(this, MailComposer);\n\n    this.mail = mail || {};\n    this.message = false;\n  }\n  /**\n   * Builds MimeNode instance\n   */\n\n\n  _createClass(MailComposer, [{\n    key: \"compile\",\n    value: function compile() {\n      var _this = this;\n\n      this._alternatives = this.getAlternatives();\n      this._htmlNode = this._alternatives.filter(function (alternative) {\n        return /^text\\/html\\b/i.test(alternative.contentType);\n      }).pop();\n      this._attachments = this.getAttachments(!!this._htmlNode);\n      this._useRelated = !!(this._htmlNode && this._attachments.related.length);\n      this._useAlternative = this._alternatives.length > 1;\n      this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1; // Compose MIME tree\n\n      if (this.mail.raw) {\n        this.message = new MimeNode().setRaw(this.mail.raw);\n      } else if (this._useMixed) {\n        this.message = this._createMixed();\n      } else if (this._useAlternative) {\n        this.message = this._createAlternative();\n      } else if (this._useRelated) {\n        this.message = this._createRelated();\n      } else {\n        this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {\n          contentType: 'text/plain',\n          content: ''\n        });\n      } // Add custom headers\n\n\n      if (this.mail.headers) {\n        this.message.addHeader(this.mail.headers);\n      } // Add headers to the root node, always overrides custom headers\n\n\n      ['from', 'sender', 'to', 'cc', 'bcc', 'reply-to', 'in-reply-to', 'references', 'subject', 'message-id', 'date'].forEach(function (header) {\n        var key = header.replace(/-(\\w)/g, function (o, c) {\n          return c.toUpperCase();\n        });\n\n        if (_this.mail[key]) {\n          _this.message.setHeader(header, _this.mail[key]);\n        }\n      }); // Sets custom envelope\n\n      if (this.mail.envelope) {\n        this.message.setEnvelope(this.mail.envelope);\n      } // ensure Message-Id value\n\n\n      this.message.messageId();\n      return this.message;\n    }\n    /**\n     * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes\n     *\n     * @param {Boolean} findRelated If true separate related attachments from attached ones\n     * @returns {Object} An object of arrays (`related` and `attached`)\n     */\n\n  }, {\n    key: \"getAttachments\",\n    value: function getAttachments(findRelated) {\n      var _this2 = this;\n\n      var icalEvent, eventObject;\n      var attachments = [].concat(this.mail.attachments || []).map(function (attachment, i) {\n        var data;\n        var isMessageNode = /^message\\//i.test(attachment.contentType);\n\n        if (/^data:/i.test(attachment.path || attachment.href)) {\n          attachment = _this2._processDataUrl(attachment);\n        }\n\n        data = {\n          contentType: attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin'),\n          contentDisposition: attachment.contentDisposition || (isMessageNode ? 'inline' : 'attachment'),\n          contentTransferEncoding: 'contentTransferEncoding' in attachment ? attachment.contentTransferEncoding : 'base64'\n        };\n\n        if (attachment.filename) {\n          data.filename = attachment.filename;\n        } else if (!isMessageNode && attachment.filename !== false) {\n          data.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);\n\n          if (data.filename.indexOf('.') < 0) {\n            data.filename += '.' + mimeFuncs.detectExtension(data.contentType);\n          }\n        }\n\n        if (/^https?:\\/\\//i.test(attachment.path)) {\n          attachment.href = attachment.path;\n          attachment.path = undefined;\n        }\n\n        if (attachment.cid) {\n          data.cid = attachment.cid;\n        }\n\n        if (attachment.raw) {\n          data.raw = attachment.raw;\n        } else if (attachment.path) {\n          data.content = {\n            path: attachment.path\n          };\n        } else if (attachment.href) {\n          data.content = {\n            href: attachment.href\n          };\n        } else {\n          data.content = attachment.content || '';\n        }\n\n        if (attachment.encoding) {\n          data.encoding = attachment.encoding;\n        }\n\n        if (attachment.headers) {\n          data.headers = attachment.headers;\n        }\n\n        return data;\n      });\n\n      if (this.mail.icalEvent) {\n        if (typeof this.mail.icalEvent === 'object' && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {\n          icalEvent = this.mail.icalEvent;\n        } else {\n          icalEvent = {\n            content: this.mail.icalEvent\n          };\n        }\n\n        eventObject = {};\n        Object.keys(icalEvent).forEach(function (key) {\n          eventObject[key] = icalEvent[key];\n        });\n        eventObject.contentType = 'application/ics';\n\n        if (!eventObject.headers) {\n          eventObject.headers = {};\n        }\n\n        eventObject.filename = eventObject.filename || 'invite.ics';\n        eventObject.headers['Content-Disposition'] = 'attachment';\n        eventObject.headers['Content-Transfer-Encoding'] = 'base64';\n      }\n\n      if (!findRelated) {\n        return {\n          attached: attachments.concat(eventObject || []),\n          related: []\n        };\n      } else {\n        return {\n          attached: attachments.filter(function (attachment) {\n            return !attachment.cid;\n          }).concat(eventObject || []),\n          related: attachments.filter(function (attachment) {\n            return !!attachment.cid;\n          })\n        };\n      }\n    }\n    /**\n     * List alternatives. Resulting objects can be used as input for MimeNode nodes\n     *\n     * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well\n     */\n\n  }, {\n    key: \"getAlternatives\",\n    value: function getAlternatives() {\n      var _this3 = this;\n\n      var alternatives = [],\n          text,\n          html,\n          watchHtml,\n          icalEvent,\n          eventObject;\n\n      if (this.mail.text) {\n        if (typeof this.mail.text === 'object' && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {\n          text = this.mail.text;\n        } else {\n          text = {\n            content: this.mail.text\n          };\n        }\n\n        text.contentType = 'text/plain' + (!text.encoding && mimeFuncs.isPlainText(text.content) ? '' : '; charset=utf-8');\n      }\n\n      if (this.mail.watchHtml) {\n        if (typeof this.mail.watchHtml === 'object' && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {\n          watchHtml = this.mail.watchHtml;\n        } else {\n          watchHtml = {\n            content: this.mail.watchHtml\n          };\n        }\n\n        watchHtml.contentType = 'text/watch-html' + (!watchHtml.encoding && mimeFuncs.isPlainText(watchHtml.content) ? '' : '; charset=utf-8');\n      } // only include the calendar alternative if there are no attachments\n      // otherwise you might end up in a blank screen on some clients\n\n\n      if (this.mail.icalEvent && !(this.mail.attachments && this.mail.attachments.length)) {\n        if (typeof this.mail.icalEvent === 'object' && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {\n          icalEvent = this.mail.icalEvent;\n        } else {\n          icalEvent = {\n            content: this.mail.icalEvent\n          };\n        }\n\n        eventObject = {};\n        Object.keys(icalEvent).forEach(function (key) {\n          eventObject[key] = icalEvent[key];\n        });\n\n        if (eventObject.content && typeof eventObject.content === 'object') {\n          // we are going to have the same attachment twice, so mark this to be\n          // resolved just once\n          eventObject.content._resolve = true;\n        }\n\n        eventObject.filename = false;\n        eventObject.contentType = 'text/calendar; charset=\"utf-8\"; method=' + (eventObject.method || 'PUBLISH').toString().trim().toUpperCase();\n\n        if (!eventObject.headers) {\n          eventObject.headers = {};\n        }\n      }\n\n      if (this.mail.html) {\n        if (typeof this.mail.html === 'object' && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {\n          html = this.mail.html;\n        } else {\n          html = {\n            content: this.mail.html\n          };\n        }\n\n        html.contentType = 'text/html' + (!html.encoding && mimeFuncs.isPlainText(html.content) ? '' : '; charset=utf-8');\n      }\n\n      [].concat(text || []).concat(watchHtml || []).concat(html || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach(function (alternative) {\n        var data;\n\n        if (/^data:/i.test(alternative.path || alternative.href)) {\n          alternative = _this3._processDataUrl(alternative);\n        }\n\n        data = {\n          contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || 'txt'),\n          contentTransferEncoding: alternative.contentTransferEncoding\n        };\n\n        if (alternative.filename) {\n          data.filename = alternative.filename;\n        }\n\n        if (/^https?:\\/\\//i.test(alternative.path)) {\n          alternative.href = alternative.path;\n          alternative.path = undefined;\n        }\n\n        if (alternative.raw) {\n          data.raw = alternative.raw;\n        } else if (alternative.path) {\n          data.content = {\n            path: alternative.path\n          };\n        } else if (alternative.href) {\n          data.content = {\n            href: alternative.href\n          };\n        } else {\n          data.content = alternative.content || '';\n        }\n\n        if (alternative.encoding) {\n          data.encoding = alternative.encoding;\n        }\n\n        if (alternative.headers) {\n          data.headers = alternative.headers;\n        }\n\n        alternatives.push(data);\n      });\n      return alternatives;\n    }\n    /**\n     * Builds multipart/mixed node. It should always contain different type of elements on the same level\n     * eg. text + attachments\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n\n  }, {\n    key: \"_createMixed\",\n    value: function _createMixed(parentNode) {\n      var _this4 = this;\n\n      var node;\n\n      if (!parentNode) {\n        node = new MimeNode('multipart/mixed', {\n          baseBoundary: this.mail.baseBoundary,\n          textEncoding: this.mail.textEncoding,\n          boundaryPrefix: this.mail.boundaryPrefix,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      } else {\n        node = parentNode.createChild('multipart/mixed', {\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      }\n\n      if (this._useAlternative) {\n        this._createAlternative(node);\n      } else if (this._useRelated) {\n        this._createRelated(node);\n      }\n\n      [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach(function (element) {\n        // if the element is a html node from related subpart then ignore it\n        if (!_this4._useRelated || element !== _this4._htmlNode) {\n          _this4._createContentNode(node, element);\n        }\n      });\n      return node;\n    }\n    /**\n     * Builds multipart/alternative node. It should always contain same type of elements on the same level\n     * eg. text + html view of the same data\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n\n  }, {\n    key: \"_createAlternative\",\n    value: function _createAlternative(parentNode) {\n      var _this5 = this;\n\n      var node;\n\n      if (!parentNode) {\n        node = new MimeNode('multipart/alternative', {\n          baseBoundary: this.mail.baseBoundary,\n          textEncoding: this.mail.textEncoding,\n          boundaryPrefix: this.mail.boundaryPrefix,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      } else {\n        node = parentNode.createChild('multipart/alternative', {\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      }\n\n      this._alternatives.forEach(function (alternative) {\n        if (_this5._useRelated && _this5._htmlNode === alternative) {\n          _this5._createRelated(node);\n        } else {\n          _this5._createContentNode(node, alternative);\n        }\n      });\n\n      return node;\n    }\n    /**\n     * Builds multipart/related node. It should always contain html node with related attachments\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @returns {Object} MimeNode node element\n     */\n\n  }, {\n    key: \"_createRelated\",\n    value: function _createRelated(parentNode) {\n      var _this6 = this;\n\n      var node;\n\n      if (!parentNode) {\n        node = new MimeNode('multipart/related; type=\"text/html\"', {\n          baseBoundary: this.mail.baseBoundary,\n          textEncoding: this.mail.textEncoding,\n          boundaryPrefix: this.mail.boundaryPrefix,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      } else {\n        node = parentNode.createChild('multipart/related; type=\"text/html\"', {\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      }\n\n      this._createContentNode(node, this._htmlNode);\n\n      this._attachments.related.forEach(function (alternative) {\n        return _this6._createContentNode(node, alternative);\n      });\n\n      return node;\n    }\n    /**\n     * Creates a regular node with contents\n     *\n     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n     * @param {Object} element Node data\n     * @returns {Object} MimeNode node element\n     */\n\n  }, {\n    key: \"_createContentNode\",\n    value: function _createContentNode(parentNode, element) {\n      element = element || {};\n      element.content = element.content || '';\n      var node;\n      var encoding = (element.encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n\n      if (!parentNode) {\n        node = new MimeNode(element.contentType, {\n          filename: element.filename,\n          baseBoundary: this.mail.baseBoundary,\n          textEncoding: this.mail.textEncoding,\n          boundaryPrefix: this.mail.boundaryPrefix,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess\n        });\n      } else {\n        node = parentNode.createChild(element.contentType, {\n          filename: element.filename,\n          disableUrlAccess: this.mail.disableUrlAccess,\n          disableFileAccess: this.mail.disableFileAccess,\n          normalizeHeaderKey: this.mail.normalizeHeaderKey\n        });\n      } // add custom headers\n\n\n      if (element.headers) {\n        node.addHeader(element.headers);\n      }\n\n      if (element.cid) {\n        node.setHeader('Content-Id', '<' + element.cid.replace(/[<>]/g, '') + '>');\n      }\n\n      if (element.contentTransferEncoding) {\n        node.setHeader('Content-Transfer-Encoding', element.contentTransferEncoding);\n      } else if (this.mail.encoding && /^text\\//i.test(element.contentType)) {\n        node.setHeader('Content-Transfer-Encoding', this.mail.encoding);\n      }\n\n      if (!/^text\\//i.test(element.contentType) || element.contentDisposition) {\n        node.setHeader('Content-Disposition', element.contentDisposition || (element.cid ? 'inline' : 'attachment'));\n      }\n\n      if (typeof element.content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n        element.content = Buffer.from(element.content, encoding);\n      } // prefer pregenerated raw content\n\n\n      if (element.raw) {\n        node.setRaw(element.raw);\n      } else {\n        node.setContent(element.content);\n      }\n\n      return node;\n    }\n    /**\n     * Parses data uri and converts it to a Buffer\n     *\n     * @param {Object} element Content element\n     * @return {Object} Parsed element\n     */\n\n  }, {\n    key: \"_processDataUrl\",\n    value: function _processDataUrl(element) {\n      var parts = (element.path || element.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n\n      if (!parts) {\n        return element;\n      }\n\n      element.content = /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2]));\n\n      if ('path' in element) {\n        element.path = false;\n      }\n\n      if ('href' in element) {\n        element.href = false;\n      }\n\n      parts[1].split(';').forEach(function (item) {\n        if (/^\\w+\\/[^/]+$/i.test(item)) {\n          element.contentType = element.contentType || item.toLowerCase();\n        }\n      });\n      return element;\n    }\n  }]);\n\n  return MailComposer;\n}();\n\nmodule.exports = MailComposer;","map":null,"metadata":{},"sourceType":"script"}