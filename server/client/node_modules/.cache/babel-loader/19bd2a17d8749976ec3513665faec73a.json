{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/inherits\");\n\nvar EventEmitter = require('events');\n\nvar SMTPConnection = require('../smtp-connection');\n\nvar wellKnown = require('../well-known');\n\nvar shared = require('../shared');\n\nvar XOAuth2 = require('../xoauth2');\n\nvar packageData = require('../../package.json');\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\n\n\nvar SMTPTransport =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(SMTPTransport, _EventEmitter);\n\n  function SMTPTransport(options) {\n    var _this;\n\n    _classCallCheck(this, SMTPTransport);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SMTPTransport).call(this));\n    options = options || {};\n\n    if (typeof options === 'string') {\n      options = {\n        url: options\n      };\n    }\n\n    var urlData;\n    var service = options.service;\n\n    if (typeof options.getSocket === 'function') {\n      _this.getSocket = options.getSocket;\n    }\n\n    if (options.url) {\n      urlData = shared.parseConnectionUrl(options.url);\n      service = service || urlData.service;\n    }\n\n    _this.options = shared.assign(false, // create new object\n    options, // regular options\n    urlData, // url options\n    service && wellKnown(service) // wellknown options\n    );\n    _this.logger = shared.getLogger(_this.options, {\n      component: _this.options.component || 'smtp-transport'\n    }); // temporary object\n\n    var connection = new SMTPConnection(_this.options);\n    _this.name = 'SMTP';\n    _this.version = packageData.version + '[client:' + connection.version + ']';\n\n    if (_this.options.auth) {\n      _this.auth = _this.getAuth({});\n    }\n\n    return _this;\n  }\n  /**\n   * Placeholder function for creating proxy sockets. This method immediatelly returns\n   * without a socket\n   *\n   * @param {Object} options Connection options\n   * @param {Function} callback Callback function to run with the socket keys\n   */\n\n\n  _createClass(SMTPTransport, [{\n    key: \"getSocket\",\n    value: function getSocket(options, callback) {\n      // return immediatelly\n      return setImmediate(function () {\n        return callback(null, false);\n      });\n    }\n  }, {\n    key: \"getAuth\",\n    value: function getAuth(authOpts) {\n      var _this2 = this;\n\n      if (!authOpts) {\n        return this.auth;\n      }\n\n      var hasAuth = false;\n      var authData = {};\n\n      if (this.options.auth && typeof this.options.auth === 'object') {\n        Object.keys(this.options.auth).forEach(function (key) {\n          hasAuth = true;\n          authData[key] = _this2.options.auth[key];\n        });\n      }\n\n      if (authOpts && typeof authOpts === 'object') {\n        Object.keys(authOpts).forEach(function (key) {\n          hasAuth = true;\n          authData[key] = authOpts[key];\n        });\n      }\n\n      if (!hasAuth) {\n        return false;\n      }\n\n      switch ((authData.type || '').toString().toUpperCase()) {\n        case 'OAUTH2':\n          {\n            if (!authData.service && !authData.user) {\n              return false;\n            }\n\n            var oauth2 = new XOAuth2(authData, this.logger);\n            oauth2.provisionCallback = this.mailer && this.mailer.get('oauth2_provision_cb') || oauth2.provisionCallback;\n            oauth2.on('token', function (token) {\n              return _this2.mailer.emit('token', token);\n            });\n            oauth2.on('error', function (err) {\n              return _this2.emit('error', err);\n            });\n            return {\n              type: 'OAUTH2',\n              user: authData.user,\n              oauth2: oauth2,\n              method: 'XOAUTH2'\n            };\n          }\n\n        default:\n          return {\n            type: (authData.type || '').toString().toUpperCase() || 'LOGIN',\n            user: authData.user,\n            credentials: {\n              user: authData.user || '',\n              pass: authData.pass,\n              options: authData.options\n            },\n            method: (authData.method || '').trim().toUpperCase() || false\n          };\n      }\n    }\n    /**\n     * Sends an e-mail using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(mail, callback) {\n      var _this3 = this;\n\n      this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n          return callback(err);\n        }\n\n        var returned = false;\n        var options = _this3.options;\n\n        if (socketOptions && socketOptions.connection) {\n          _this3.logger.info({\n            tnx: 'proxy',\n            remoteAddress: socketOptions.connection.remoteAddress,\n            remotePort: socketOptions.connection.remotePort,\n            destHost: options.host || '',\n            destPort: options.port || '',\n            action: 'connected'\n          }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || ''); // only copy options if we need to modify it\n\n\n          options = shared.assign(false, options);\n          Object.keys(socketOptions).forEach(function (key) {\n            options[key] = socketOptions[key];\n          });\n        }\n\n        var connection = new SMTPConnection(options);\n        connection.once('error', function (err) {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          connection.close();\n          return callback(err);\n        });\n        connection.once('end', function () {\n          if (returned) {\n            return;\n          }\n\n          var timer = setTimeout(function () {\n            if (returned) {\n              return;\n            }\n\n            returned = true; // still have not returned, this means we have an unexpected connection close\n\n            var err = new Error('Unexpected socket close');\n\n            if (connection && connection._socket && connection._socket.upgrading) {\n              // starttls connection errors\n              err.code = 'ETLS';\n            }\n\n            callback(err);\n          }, 1000);\n\n          try {\n            timer.unref();\n          } catch (E) {// Ignore. Happens on envs with non-node timer implementation\n          }\n        });\n\n        var sendMessage = function sendMessage() {\n          var envelope = mail.message.getEnvelope();\n          var messageId = mail.message.messageId();\n          var recipients = [].concat(envelope.to || []);\n\n          if (recipients.length > 3) {\n            recipients.push('...and ' + recipients.splice(2).length + ' more');\n          }\n\n          if (mail.data.dsn) {\n            envelope.dsn = mail.data.dsn;\n          }\n\n          _this3.logger.info({\n            tnx: 'send',\n            messageId: messageId\n          }, 'Sending message %s to <%s>', messageId, recipients.join(', '));\n\n          connection.send(envelope, mail.message.createReadStream(), function (err, info) {\n            returned = true;\n            connection.close();\n\n            if (err) {\n              _this3.logger.error({\n                err: err,\n                tnx: 'send'\n              }, 'Send error for %s: %s', messageId, err.message);\n\n              return callback(err);\n            }\n\n            info.envelope = {\n              from: envelope.from,\n              to: envelope.to\n            };\n            info.messageId = messageId;\n\n            try {\n              return callback(null, info);\n            } catch (E) {\n              _this3.logger.error({\n                err: E,\n                tnx: 'callback'\n              }, 'Callback error for %s: %s', messageId, E.message);\n            }\n          });\n        };\n\n        connection.connect(function () {\n          if (returned) {\n            return;\n          }\n\n          var auth = _this3.getAuth(mail.data.auth);\n\n          if (auth) {\n            connection.login(auth, function (err) {\n              if (auth && auth !== _this3.auth && auth.oauth2) {\n                auth.oauth2.removeAllListeners();\n              }\n\n              if (returned) {\n                return;\n              }\n\n              if (err) {\n                returned = true;\n                connection.close();\n                return callback(err);\n              }\n\n              sendMessage();\n            });\n          } else {\n            sendMessage();\n          }\n        });\n      });\n    }\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(callback) {\n      var _this4 = this;\n\n      var promise;\n\n      if (!callback) {\n        promise = new Promise(function (resolve, reject) {\n          callback = shared.callbackPromise(resolve, reject);\n        });\n      }\n\n      this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n          return callback(err);\n        }\n\n        var options = _this4.options;\n\n        if (socketOptions && socketOptions.connection) {\n          _this4.logger.info({\n            tnx: 'proxy',\n            remoteAddress: socketOptions.connection.remoteAddress,\n            remotePort: socketOptions.connection.remotePort,\n            destHost: options.host || '',\n            destPort: options.port || '',\n            action: 'connected'\n          }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n\n          options = shared.assign(false, options);\n          Object.keys(socketOptions).forEach(function (key) {\n            options[key] = socketOptions[key];\n          });\n        }\n\n        var connection = new SMTPConnection(options);\n        var returned = false;\n        connection.once('error', function (err) {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          connection.close();\n          return callback(err);\n        });\n        connection.once('end', function () {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          return callback(new Error('Connection closed'));\n        });\n\n        var finalize = function finalize() {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          connection.quit();\n          return callback(null, true);\n        };\n\n        connection.connect(function () {\n          if (returned) {\n            return;\n          }\n\n          var authData = _this4.getAuth({});\n\n          if (authData) {\n            connection.login(authData, function (err) {\n              if (returned) {\n                return;\n              }\n\n              if (err) {\n                returned = true;\n                connection.close();\n                return callback(err);\n              }\n\n              finalize();\n            });\n          } else {\n            finalize();\n          }\n        });\n      });\n      return promise;\n    }\n    /**\n     * Releases resources\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.auth && this.auth.oauth2) {\n        this.auth.oauth2.removeAllListeners();\n      }\n\n      this.emit('close');\n    }\n  }]);\n\n  return SMTPTransport;\n}(EventEmitter); // expose to the world\n\n\nmodule.exports = SMTPTransport;","map":null,"metadata":{},"sourceType":"script"}