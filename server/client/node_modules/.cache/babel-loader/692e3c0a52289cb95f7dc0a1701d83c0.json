{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/tryckhov/Dropbox/Programming/Web Development/React/g12-site/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Stream = require('stream').Stream;\n\nvar fetch = require('../fetch');\n\nvar crypto = require('crypto');\n\nvar shared = require('../shared');\n/**\n * XOAUTH2 access_token generator for Gmail.\n * Create client ID for web applications in Google API console to use it.\n * See Offline Access for receiving the needed refreshToken for an user\n * https://developers.google.com/accounts/docs/OAuth2WebServer#offline\n *\n * Usage for generating access tokens with a custom method using provisionCallback:\n * provisionCallback(user, renew, callback)\n *   * user is the username to get the token for\n *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed\n *   * callback is the callback to run with (error, accessToken [, expires])\n *     * accessToken is a string\n *     * expires is an optional expire time in milliseconds\n * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself\n *\n * @constructor\n * @param {Object} options Client information for token generation\n * @param {String} options.user User e-mail address\n * @param {String} options.clientId Client ID value\n * @param {String} options.clientSecret Client secret value\n * @param {String} options.refreshToken Refresh token for an user\n * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'\n * @param {String} options.accessToken An existing valid accessToken\n * @param {String} options.privateKey Private key for JSW\n * @param {Number} options.expires Optional Access Token expire time in ms\n * @param {Number} options.timeout Optional TTL for Access Token in seconds\n * @param {Function} options.provisionCallback Function to run when a new access token is required\n */\n\n\nvar XOAuth2 =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inherits(XOAuth2, _Stream);\n\n  function XOAuth2(options, logger) {\n    var _this;\n\n    _classCallCheck(this, XOAuth2);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(XOAuth2).call(this));\n    _this.options = options || {};\n\n    if (options && options.serviceClient) {\n      if (!options.privateKey || !options.user) {\n        setImmediate(function () {\n          return _this.emit('error', new Error('Options \"privateKey\" and \"user\" are required for service account!'));\n        });\n        return _possibleConstructorReturn(_this);\n      }\n\n      var serviceRequestTimeout = Math.min(Math.max(Number(_this.options.serviceRequestTimeout) || 0, 0), 3600);\n      _this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;\n    }\n\n    _this.logger = shared.getLogger({\n      logger: logger\n    }, {\n      component: _this.options.component || 'OAuth2'\n    });\n    _this.provisionCallback = typeof _this.options.provisionCallback === 'function' ? _this.options.provisionCallback : false;\n    _this.options.accessUrl = _this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';\n    _this.options.customHeaders = _this.options.customHeaders || {};\n    _this.options.customParams = _this.options.customParams || {};\n    _this.accessToken = _this.options.accessToken || false;\n\n    if (_this.options.expires && Number(_this.options.expires)) {\n      _this.expires = _this.options.expires;\n    } else {\n      var timeout = Math.max(Number(_this.options.timeout) || 0, 0);\n      _this.expires = timeout && Date.now() + timeout * 1000 || 0;\n    }\n\n    return _this;\n  }\n  /**\n   * Returns or generates (if previous has expired) a XOAuth2 token\n   *\n   * @param {Boolean} renew If false then use cached access token (if available)\n   * @param {Function} callback Callback function with error object and token string\n   */\n\n\n  _createClass(XOAuth2, [{\n    key: \"getToken\",\n    value: function getToken(renew, callback) {\n      var _this2 = this;\n\n      if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {\n        return callback(null, this.accessToken);\n      }\n\n      var generateCallback = function generateCallback() {\n        if (arguments.length <= 0 ? undefined : arguments[0]) {\n          _this2.logger.error({\n            err: arguments.length <= 0 ? undefined : arguments[0],\n            tnx: 'OAUTH2',\n            user: _this2.options.user,\n            action: 'renew'\n          }, 'Failed generating new Access Token for %s', _this2.options.user);\n        } else {\n          _this2.logger.info({\n            tnx: 'OAUTH2',\n            user: _this2.options.user,\n            action: 'renew'\n          }, 'Generated new Access Token for %s', _this2.options.user);\n        }\n\n        callback.apply(void 0, arguments);\n      };\n\n      if (this.provisionCallback) {\n        this.provisionCallback(this.options.user, !!renew, function (err, accessToken, expires) {\n          if (!err && accessToken) {\n            _this2.accessToken = accessToken;\n            _this2.expires = expires || 0;\n          }\n\n          generateCallback(err, accessToken);\n        });\n      } else {\n        this.generateToken(generateCallback);\n      }\n    }\n    /**\n     * Updates token values\n     *\n     * @param {String} accessToken New access token\n     * @param {Number} timeout Access token lifetime in seconds\n     *\n     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}\n     */\n\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(accessToken, timeout) {\n      this.accessToken = accessToken;\n      timeout = Math.max(Number(timeout) || 0, 0);\n      this.expires = timeout && Date.now() + timeout * 1000 || 0;\n      this.emit('token', {\n        user: this.options.user,\n        accessToken: accessToken || '',\n        expires: this.expires\n      });\n    }\n    /**\n     * Generates a new XOAuth2 token with the credentials provided at initialization\n     *\n     * @param {Function} callback Callback function with error object and token string\n     */\n\n  }, {\n    key: \"generateToken\",\n    value: function generateToken(callback) {\n      var _this3 = this;\n\n      var urlOptions;\n      var loggedUrlOptions;\n\n      if (this.options.serviceClient) {\n        // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n        var iat = Math.floor(Date.now() / 1000); // unix time\n\n        var tokenData = {\n          iss: this.options.serviceClient,\n          scope: this.options.scope || 'https://mail.google.com/',\n          sub: this.options.user,\n          aud: this.options.accessUrl,\n          iat: iat,\n          exp: iat + this.options.serviceRequestTimeout\n        };\n        var token = this.jwtSignRS256(tokenData);\n        urlOptions = {\n          grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n          assertion: token\n        };\n        loggedUrlOptions = {\n          grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n          assertion: tokenData\n        };\n      } else {\n        if (!this.options.refreshToken) {\n          return callback(new Error('Can\\x27t create new access token for user'));\n        } // web app - https://developers.google.com/identity/protocols/OAuth2WebServer\n\n\n        urlOptions = {\n          client_id: this.options.clientId || '',\n          client_secret: this.options.clientSecret || '',\n          refresh_token: this.options.refreshToken,\n          grant_type: 'refresh_token'\n        };\n        loggedUrlOptions = {\n          client_id: this.options.clientId || '',\n          client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',\n          refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',\n          grant_type: 'refresh_token'\n        };\n      }\n\n      Object.keys(this.options.customParams).forEach(function (key) {\n        urlOptions[key] = _this3.options.customParams[key];\n        loggedUrlOptions[key] = _this3.options.customParams[key];\n      });\n      this.logger.debug({\n        tnx: 'OAUTH2',\n        user: this.options.user,\n        action: 'generate'\n      }, 'Requesting token using: %s', JSON.stringify(loggedUrlOptions));\n      this.postRequest(this.options.accessUrl, urlOptions, this.options, function (error, body) {\n        var data;\n\n        if (error) {\n          return callback(error);\n        }\n\n        try {\n          data = JSON.parse(body.toString());\n        } catch (E) {\n          return callback(E);\n        }\n\n        if (!data || typeof data !== 'object') {\n          _this3.logger.debug({\n            tnx: 'OAUTH2',\n            user: _this3.options.user,\n            action: 'post'\n          }, 'Response: %s', (body || '').toString());\n\n          return callback(new Error('Invalid authentication response'));\n        }\n\n        var logData = {};\n        Object.keys(data).forEach(function (key) {\n          if (key !== 'access_token') {\n            logData[key] = data[key];\n          } else {\n            logData[key] = (data[key] || '').toString().substr(0, 6) + '...';\n          }\n        });\n\n        _this3.logger.debug({\n          tnx: 'OAUTH2',\n          user: _this3.options.user,\n          action: 'post'\n        }, 'Response: %s', JSON.stringify(logData));\n\n        if (data.error) {\n          return callback(new Error(data.error));\n        }\n\n        if (data.access_token) {\n          _this3.updateToken(data.access_token, data.expires_in);\n\n          return callback(null, _this3.accessToken);\n        }\n\n        return callback(new Error('No access token'));\n      });\n    }\n    /**\n     * Converts an access_token and user id into a base64 encoded XOAuth2 token\n     *\n     * @param {String} [accessToken] Access token string\n     * @return {String} Base64 encoded token for IMAP or SMTP login\n     */\n\n  }, {\n    key: \"buildXOAuth2Token\",\n    value: function buildXOAuth2Token(accessToken) {\n      var authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];\n      return Buffer.from(authData.join('\\x01'), 'utf-8').toString('base64');\n    }\n    /**\n     * Custom POST request handler.\n     * This is only needed to keep paths short in Windows – usually this module\n     * is a dependency of a dependency and if it tries to require something\n     * like the request module the paths get way too long to handle for Windows.\n     * As we do only a simple POST request we do not actually require complicated\n     * logic support (no redirects, no nothing) anyway.\n     *\n     * @param {String} url Url to POST to\n     * @param {String|Buffer} payload Payload to POST\n     * @param {Function} callback Callback function with (err, buff)\n     */\n\n  }, {\n    key: \"postRequest\",\n    value: function postRequest(url, payload, params, callback) {\n      var returned = false;\n      var chunks = [];\n      var chunklen = 0;\n      var req = fetch(url, {\n        method: 'post',\n        headers: params.customHeaders,\n        body: payload,\n        allowErrorResponse: true\n      });\n      req.on('readable', function () {\n        var chunk;\n\n        while ((chunk = req.read()) !== null) {\n          chunks.push(chunk);\n          chunklen += chunk.length;\n        }\n      });\n      req.once('error', function (err) {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        return callback(err);\n      });\n      req.once('end', function () {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        return callback(null, Buffer.concat(chunks, chunklen));\n      });\n    }\n    /**\n     * Encodes a buffer or a string into Base64url format\n     *\n     * @param {Buffer|String} data The data to convert\n     * @return {String} The encoded string\n     */\n\n  }, {\n    key: \"toBase64URL\",\n    value: function toBase64URL(data) {\n      if (typeof data === 'string') {\n        data = Buffer.from(data);\n      }\n\n      return data.toString('base64').replace(/[=]+/g, '') // remove '='s\n      .replace(/\\+/g, '-') // '+' → '-'\n      .replace(/\\//g, '_'); // '/' → '_'\n    }\n    /**\n     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)\n     *\n     * @param {Object} payload The payload to include in the generated token\n     * @return {String} The generated and signed token\n     */\n\n  }, {\n    key: \"jwtSignRS256\",\n    value: function jwtSignRS256(payload) {\n      var _this4 = this;\n\n      payload = ['{\"alg\":\"RS256\",\"typ\":\"JWT\"}', JSON.stringify(payload)].map(function (val) {\n        return _this4.toBase64URL(val);\n      }).join('.');\n      var signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);\n      return payload + '.' + this.toBase64URL(signature);\n    }\n  }]);\n\n  return XOAuth2;\n}(Stream);\n\nmodule.exports = XOAuth2;","map":null,"metadata":{},"sourceType":"script"}